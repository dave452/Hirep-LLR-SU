/*************************************************************************** \
 * Copyright (c) 2008, Claudio Pica                                          *   
 * All rights reserved.                                                      * 
\***************************************************************************/

/*******************************************************************************
 *
 * File update_llr.c
 *
 * Update programs
 *
 *******************************************************************************/
#include "suN.h"
#include "utils.h"
#include "global.h"
#include "logger.h"
#include "random.h"
#include "communications.h"
#include <math.h>
#include "update.h"
#include "observables.h"
#include <stdlib.h>

typedef struct {
  int nrm,nth;
  int it;
  double starta;
  double a;
  double S0;
  double dS;
  double E;
} llrparamsHB;

static llrparamsHB llrp;

//reset it to 0 and rhoa to initial value
void restart_robbinsmonro_hb(){
  llrp.it=8;
  llrp.a=llrp.starta;
  llrp.E=avr_plaquette()*6.0*GLB_VOLUME;
}

void init_robbinsmonro_hb(int nrm,int nth,double starta,int it,double dS,double S0){
  llrp.nrm=nrm;
  llrp.nth=nth;
  llrp.it=it;
  llrp.starta=starta;
  llrp.dS=dS;
  llrp.S0=S0;
  llrp.E=avr_plaquette()*6.0*GLB_VOLUME;
  lprintf("MAIN",0,"Bringing the system to the interval (S0,dS) = (%f, %f) ...\n", llrp.S0, llrp.dS);
  anneal(&(llrp.E), llrp.S0, llrp.dS);
  lprintf("MAIN",0,"System brought to the interval (S0,dS) = (%f, %f)\n", llrp.S0, llrp.dS);
}
  
double get_llr_a_hb(void){
  return llrp.a;	
}
//
double getS0_hb(void){
  return llrp.S0;	
}
//
//double getdS(void){
//  return llrp.dS;	
//}
//
//

void thermrobbinsmonro_hb(void){
	double Emin, Emax;
	Emin = llrp.S0 - .5*llrp.dS;
	Emax = llrp.S0 + .5*llrp.dS;
	double * E = &(llrp.E);
	update_constrained(llrp.a, 1,0,E,Emin,Emax);
}

//void llr_fixed_a_update(void){
//  update_constrained(llrp.a, 1,0,&(llrp.E),llrp.Smin,llrp.Smax);
//
//
//#ifdef WITH_UMBRELLA
//  umbrella_swap(&S_llr,&llrp.S0,&llrp.a,&llrp.dS);
//#endif
//}




	
void robbinsmonro_hb(void){
  
  int rmstep;
  double Emin, Emax;
  lprintf("ROBBINSMONRO",10,"Computing Emin, Emax.. \n");
  Emin = llrp.S0 - .5*llrp.dS;
  Emax = llrp.S0 + .5*llrp.dS;
  lprintf("ROBBINSMONRO",10,"..Done!\n");
  double * E = &(llrp.E);
    
  
  lprintf("ROBBINSMONRO",10,"Starting thermalization at fixed a=%f\n",llrp.a);
  for(rmstep=0;rmstep<llrp.nth;rmstep++){
    //lprintf("llr",10,"Therm: %d\n",rmstep);
    update_constrained(llrp.a, 1,0,E,Emin,Emax);
    //lprintf("llr",10,"Therm: %d Done!\n",rmstep);
  }
  lprintf("ROBBINSMONRO",10,"...Done!\n");
  
  
  
 //printf("%f\n", llrp.a); 
  double avr=0.;
  lprintf("ROBBINSMONRO",10,"Starting RM with Emin: %f Emax: %f \n",Emin,Emax);
  for(rmstep=0;rmstep<llrp.nrm;rmstep++){
    update_constrained(llrp.a, 1,0,E,Emin,Emax);
    lprintf("ROBBINSMONRO",10,"RM Step: %d GMC Iter: %d E=%lf \n",llrp.it,rmstep,llrp.E);
    //printf("E = %f\n", avr_plaquette()*6.*GLB_VOLUME); 
    avr+=llrp.E;
  }
  
  avr/=(double)llrp.nrm;
  double deltaa =(avr-llrp.S0)*12./(llrp.dS*llrp.dS*llrp.it); 
  llrp.a -=(avr-llrp.S0)*12./(llrp.dS*llrp.dS*llrp.it);
#ifdef WITH_UMBRELLA
  lprintf("ROBBINSMONRO",0,"Smin = %1.5f, S0 = %1.5f, Smax = %1.5f, a = %1.5f, <S-S0> = %f, delta_a=%1.5f, t=%d\n", Emin, llrp.S0, Emax, llrp.a, avr-llrp.S0,deltaa, llrp.it);
  //if( llrp.it %10 == 0 ) {
  umbrella_swap(&(llrp.E),&llrp.S0,&llrp.a,&llrp.dS);
  //Emin = llrp.S0 - .5*llrp.dS;
  //Emax = llrp.S0 + .5*llrp.dS;
  //}
  lprintf("ROBBINSMONRO",0,"Smin = %1.5f, S0 = %1.5f, Smax = %1.5f, a = %1.5f, <S-S0> = %f, delta_a=%1.5f, t=%d\n", Emin, llrp.S0, Emax, llrp.a, avr-llrp.S0,deltaa, llrp.it);
#endif
  llrp.it++;
}


//#ifdef WITH_UMBRELLA
//typedef struct{
//  double S_llr;
//  double dS;
//  double S0;
//  double a;
//  double deltaS;
//  int rep;
//  int repnext;
//} reppar_hb;
//////
//////
//////
//static int compare_S0_hb(const void *p, const void *q) {
//  //lprintf("llr:compare",0,"inside compare \n");
//  reppar_hb x=*(reppar_hb *)p;
//  reppar_hb y=*(reppar_hb *)q;
//
//
//  if (x.S0 < y.S0 )
//    return -1;  // Return -1 if you want ascending, 1 if you want descending order. 
//  else if (x.S0 > y.S0 )
//    return 1;   // Return 1 if you want ascending, -1 if you want descending order. 
//
//  return 0;
//}
////
////
//static int compare_deltaS_hb(const void *p, const void *q) {
//  //lprintf("llr:compare",0,"inside compare \n");
//  reppar_hb x=*(reppar_hb *)p;
//  reppar_hb y=*(reppar_hb *)q;
//
//
//  if (x.deltaS < y.deltaS )
//    return -1;  // Return -1 if you want ascending, 1 if you want descending order. 
//  else if (x.deltaS > y.deltaS )
//    return 1;   // Return 1 if you want ascending, -1 if you want descending order. 
//
//  return 0;
//}
//
//
//void swap_hb(double *data){
//  reppar_hb drep[N_REP];
//  int toswap[N_REP];
//  double rand,temp;
//  int i,j;
//
//  toswap[N_REP-1]=1;
//
////  //sorting the replicas with respect of their energy  S0 so we can swap nearest neighbourgh
////
//  for(i=0;i<N_REP;i++){
//    
//    drep[i].S_llr=data[4*i];
//    drep[i].S0=data[4*i+1];
//    drep[i].a=data[4*i+2];
//    drep[i].dS=data[4*i+3];
//    drep[i].rep=i;
//
//  }
//
//  qsort(drep,N_REP,sizeof(drep[0]),compare_S0_hb);
//
//  //sorting with respect of the difference in hamiltonian between r and r+1 where r is the replica
//
//  for(i=0;i<N_REP-1;i++){
//    toswap[i]=1;
//    drep[i].repnext=drep[i+1].rep;
//    drep[i].deltaS= (drep[i+1].a - drep[i].a) * ( drep[i+1].S_llr - drep[i].S_llr) ;
//  }
//  
//  qsort(drep,N_REP-1,sizeof(drep[0]),compare_deltaS_hb);
//  
//  //swap of replicas
//
//  for(i=0;i<N_REP-1;i++){
//    if(toswap[drep[i].rep] && toswap[drep[i].repnext] ){
//      toswap[drep[i].rep]=0;
//      toswap[drep[i].repnext]=0;
//      if(drep[i].deltaS<0){
//	for(j=0;j<4;j++){                                                                                                                                                                                                                      
//	  temp=data[4*drep[i].rep+j];                                                                                                                                                                                                                      
//	  data[4*drep[i].rep+j]=data[4*drep[i].repnext+j];                                                                                                                                                                                                           
//	  data[4*drep[i].repnext+j]=temp; 
//	}
//	lprintf("SWAP", 10, "Replicas %d and %d swapped!\n",drep[i].rep,drep[i].repnext); 
//	
//      }else{
//	ranlxd(&rand,1);
//	if(rand < exp(-drep[i].deltaS)){
//	  for(j=0;j<4;j++){                                                                                                                                                                                                                      
//	    temp=data[4*drep[i].rep+j];                                                                                                                                                                                                                      
//	    data[4*drep[i].rep+j]=data[4*drep[i].repnext+j];                                                                                                                                                                                                           
//	    data[4*drep[i].repnext+j]=temp; 
//	  }	
//	}
//	lprintf("SWAP", 10, "Replicas %d and %d swapped!\n",drep[i].rep,drep[i].repnext); 
//      }
//    }
//  }
//}
//
//void setreplica_hb(double *data){
//  lprintf("llr:setreplica",0,"Updating OLD LLR Param: S0 %lf,  a  %lf , dS %lf  \n",llrp.S0,llrp.a,llrp.dS);
//  llrp.S0=data[1];
//  llrp.dS=data[3];
//  llrp.a=data[2];
//  lprintf("llr:setreplica",0,"New LLR Param: S0 %lf,  a  %lf , dS %lf  \n",llrp.S0,llrp.a,llrp.dS);
//}
////
//#endif //WITH_UMBRELLA
